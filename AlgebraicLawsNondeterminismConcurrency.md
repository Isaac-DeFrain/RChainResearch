# Algebraic Laws for Nondeterminism and Concurrency - Matthew Hennessey, Robin Milner

#### Abstract
Since a nondeterministic and concurrent program may, in general, communicate repeatedly with its environment, its meaning cannot be be presented naturally as an input/output function (as is often done in the denotational approach to semantics). This is an alternative viewpoint. First, a definition is given of what it is for two programs or program parts to be equivalent for all observers; then two program parts are said to be *observation congruent* if and only if they are equivalent in all program contexts. The *behavior* of a program part, i.e. its meaning, is defined to be its observation congruence class.

Algebraic axiomatization of observation congruence for a sequence of simple languages expressing finite (terminating) behaviors. Moreover with addition of recursion and another simple extension, the algebraic language described here becomes a calculus for writing and specifying concurrent programs and for proving their properties.

## Introduction
If either the mathematics or the logic is to have any relevance, a link must be made between the denotational model and the behavior, or operational semantics, of the programs. One way of making a link is to demand that the denotational model be *fully abstract* with respect to the operational semantics. This means

> Two program phrases should have should have the same denotation if and only if the operational meaning of every program remains unchanged when one phrase is replaced by the other.

Exact meaning of behavior of nondeterministic or concurrent programs is far from clear and one possible definition is introduced in this paper. The essence of the approach:

> The behavior of a program is determined by how it communicates with an observer (#quantumstateofmind).

Begin by assuming that every program action is observable in this way; later, unobservable actions (in particular, internal communications between concurrent components) will be introduced.

The definition is applied to a sequence of simple languages for expressing programs with finite behavior, and shows that in each case it can be characterized by algebraic axioms. This leads automatically to a *fully abstract model*; it is just the *initial algebra* generated by the axioms.

## Observational Equivalence of Processes
### Equivalence
Definition of equivalence between programs based entirely on operational considerations; informally, two programs are *equivalent* when no observations can distinguish them. Further, two subprograms or program phrases are *congruent* if the result of placing each of them in any program context yields two equivalent programs. Then, considering the phrases as *modules*, one can be exchanged for the other in any program without affecting the observed behavior of the latter.

However, much is left vague by the prescription.
* What are observations?
* How can they be used to distinguish programs?

We answer those questions and obtain a precise notion of equivalence, and hence also of congruence.

In the case of deterministic sequential programs, the behavior of a program `p` is usually taken to be its input-output function `IO(p)`. Here, an observation is taken to be a pair of states (or values): an *input state* and an *output state* (if any). The programs `p` and `q` are *equivalent*, denoted `p ~ q`, if they yield the same observation sets, i.e. `IO(p) = IO(q)`. The corresponding congruence relation `~c` is then defined as follows `p ~c q` if for every suitable program context `C[]`, we have `C[p] ~ C[q]`. If the language is defined algebraically, i.e. by operations for constructing new programs from ones already defined, then `~c` turns out to be the largest congruence relation included in `~`.

However, any satisfactory comparison of the behavior of concurrent programs must take into account their intermediate states as they progress through a computation, because differing intermediate states can be exploited in different program contexts to produce different overall behavior (e.g. deadlock). With this in mind, we now proceed to a more refined notion of behavioral equivalence, called *observational equivalence*. This notion may be defined for objects more general than programs, which we call *processes*.

Let `Proc` be a set of objects that we may think of as processes. We take the view that any observation of `P \in Proc` entails some participation by `P` itself; `P` is an *active participant*, as well as the observer. Thus the act of observing a process changes its state. If we identify the state of a process with the process itself, we can say that observation changes the process into a new process. This change may not be deterministic; hence the effect of a particular type of observation - applied to an arbitrary process - may be captured by a binary relation over `Proc`. In general, we presuppose a set `I` of possible types of observation, so we then have a set of observation relations.
```
        { R(i) \subset Proc * Proc, i \in I }
```

Using these relations, we define a sequence of equivalence relations `~n` over `Proc` (`n = 0,1,2,...`), in such a way `~n+1 \subset ~n`, as follows:
* `p ~0 q` if `p,q \in Proc` (i.e. `~0 = Proc * Proc`)
* `p ~n+1 q` if for every `i \in I`,
  * `(p,p') \in R(i)` implies, for some `q'`, `(q,q') \in R(i)` and `p' ~n q'`
  * `(q,q') \in R(i)` implies, for some `p'`, `(p,p') \in R(i)` and `p' ~n q'`

The `p` and `q` are *observationally equivalent*, written `p ~ q`, if `p ~n q` for every `n`.

Thus, we have defined `~` to be `\cap_n ~n`, i.e. the intersection of `~n` for all `n`. In fact, we have taken `~` to be the limit `\cap_n En(Proc * Proc)`, where `E(S)` is defined for any `S \subset Proc * Proc` as follows: `(p,q) \in E(S)` if for every `i \in I`
* `(p,p') \in R(i)` implies, for some `q'`, `(q,q') \in R(i)` and `(p',q') \in S`
* `(q,q') \in R(i)` implies, for some `p'`, `(p,p') \in R(i)` and `(p',q') \in S`

Now if `E` has the property that `E(\cap_n Sn) = \cap_n (E(Sn))` for every decreasing sequence `Sn` of relations, i.e. if `E` is *anticontinuous*, then it follows from classical fixed-point theory that `~` is the maximum fixed-point of the map `E` of relations.

`R \subset Proc * Proc` is *image-finite* if, for each `p \in Proc`, `{ p' | (p,p') \in R }` is finite. It turns out that the image-finiteness of each `R(i)`, `i \in I`, is sufficient to ensure that `E` is anticontinuous, so the following theorem holds:

> **Theorem 2.1** If `R(i)` is image-finite for each `i \in I`, then `~` is the maximum solution to `S = E(S)`.

So far we have called `i \in I` a *type* of observation, and then an instance `(p,p') \in R(i)` is a particular observation (of `p`). It can also regarded as a communication between `p` and an observer; in some of the program languages that will be introduced, we exploit this symmetry by representing communication between two processes `p` and `q`, running concurrently, as *mutual observation* between the processes.

We can also regard a single observation `(p,p') \in R(i)` as an *atomic experiment* 
